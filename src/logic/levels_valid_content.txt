import alasql from 'alasql';

// CATEGORIES for organization
export const CATEGORIES = [
    { id: 'A', name: 'Consultas SQL de AgregaciÃ³n (GROUP BY & HAVING)' },
    { id: 'B', name: 'DivisiÃ³n en SQL (Universalidad)' },
    { id: 'C', name: 'Ãlgebra Relacional (Multiple Choice)' },
    { id: 'D', name: 'Triggers (AuditorÃ­a Avanzada)' },
    { id: 'E', name: 'TeorÃ­a de Transacciones' },
    { id: 'F', name: 'Stored Procedures' }
];

/**
 * Compares two query results by VALUES only, ignoring column names.
 * This allows different column aliases (e.g., "Cantidad" vs "CantidadDispensas")
 * to be accepted as long as the data is identical.
 * 
 * @param {Array} expected - Expected result array
 * @param {Array} actual - User's result array
 * @param {Function} sortFn - Optional sorting function for consistent ordering
 * @returns {boolean} - True if results match (ignoring column names)
 */
const compareQueryResults = (expected, actual, sortFn = null) => {
    // Check if both are arrays
    if (!Array.isArray(expected) || !Array.isArray(actual)) {
        return false;
    }

    // Check same number of rows
    if (expected.length !== actual.length) {
        return false;
    }

    // Empty results are equal
    if (expected.length === 0) {
        return true;
    }

    // Sort both arrays if sortFn provided
    const sortedExpected = sortFn ? [...expected].sort(sortFn) : expected;
    const sortedActual = sortFn ? [...actual].sort(sortFn) : actual;

    // Check same number of columns in first row
    const expectedCols = Object.keys(sortedExpected[0]);
    const actualCols = Object.keys(sortedActual[0]);

    if (expectedCols.length !== actualCols.length) {
        return false;
    }

    // Compare row by row, comparing VALUES only (not keys)
    for (let i = 0; i < sortedExpected.length; i++) {
        const expectedValues = Object.values(sortedExpected[i]);
        const actualValues = Object.values(sortedActual[i]);

        // Compare values (ignoring column names)
        if (JSON.stringify(expectedValues) !== JSON.stringify(actualValues)) {
            return false;
        }
    }

    return true;
};


export const LEVELS = [
    // ============================================================================
    // CATEGORÃA A: CONSULTAS SQL DE AGREGACIÃ“N (GROUP BY & HAVING)
    // ============================================================================
    {
        id: 'A1',
        category: 'A',
        title: "Control de Saldos",
        description: "Controle que la suma de movimientos de una caja coincida con su saldo. Muestre: DescripciÃ³n, Suma Movimientos, Saldo y una columna 'Estado' que diga \"COINCIDE\" o \"NO COINCIDE\".",
        type: "sql",
        visibleTables: ['CAJAS', 'MOVIMIENTOS', 'CONCEPTOS', 'LOG'],
        initialCode: `-- Escribe tu consulta aquÃ­
SELECT * FROM CAJAS`,
        solution: `SELECT 
    C.Descripcion,
    SUM(M.Monto) AS SumaMovimientos,
    C.Saldo,
    CASE 
        WHEN SUM(M.Monto) = C.Saldo THEN 'COINCIDE'
        ELSE 'NO COINCIDE'
    END AS Estado
FROM CAJAS C
LEFT JOIN MOVIMIENTOS M ON C.CajaID = M.CajaID
GROUP BY C.CajaID, C.Descripcion, C.Saldo`,
        solutionExplanation: `
**SoluciÃ³n de CÃ¡tedra:**

\`\`\`sql
SELECT 
    C.Descripcion,
    SUM(M.Monto) AS SumaMovimientos,
    C.Saldo,
    CASE 
        WHEN SUM(M.Monto) = C.Saldo THEN 'COINCIDE'
        ELSE 'NO COINCIDE'
    END AS Estado
FROM CAJAS C
LEFT JOIN MOVIMIENTOS M ON C.CajaID = M.CajaID
GROUP BY C.CajaID, C.Descripcion, C.Saldo
\`\`\`

**Elementos clave:**
- **SUM()** para sumar movimientos por caja
- **GROUP BY** con CajaID, Descripcion y Saldo
- **CASE WHEN** para generar la columna Estado
- **LEFT JOIN** para incluir cajas sin movimientos
        `,
        validate: (userQuery) => {
            try {
                const canonicalQuery = `
                    SELECT 
                        C.Descripcion,
                        SUM(M.Monto) AS SumaMovimientos,
                        C.Saldo,
                        CASE 
                            WHEN SUM(M.Monto) = C.Saldo THEN 'COINCIDE'
                            ELSE 'NO COINCIDE'
                        END AS Estado
                    FROM CAJAS C
                    LEFT JOIN MOVIMIENTOS M ON C.CajaID = M.CajaID
                    GROUP BY C.CajaID, C.Descripcion, C.Saldo
                `;
                const expected = alasql(canonicalQuery);

                // Execute user query
                const actual = alasql(userQuery);

                const sortFn = (a, b) => a.Descripcion.localeCompare(b.Descripcion);

                // Use compareQueryResults to ignore column names
                if (compareQueryResults(expected, actual, sortFn)) {
                    return { success: true, message: "Â¡Correcto! Los resultados coinciden con la soluciÃ³n esperada." };
                } else {
                    return {
                        success: false,
                        message: "Los resultados no coinciden. Verifica: SUM(), GROUP BY, CASE WHEN y LEFT JOIN.",
                        expected,
                        actual
                    };
                }
            } catch (e) {
                return { success: false, message: "âŒ Error SQL: " + e.message, isSyntaxError: true };
            }
        }
    },
    {
        id: 'A2',
        category: 'A',
        title: "Filtro Agregado por Provincia",
        description: "Obtenga para cada Provincia y Paciente, la cantidad de dispensas, siempre que la cantidad sea mayor a 2. Si no tiene provincia, mostrar \"\".",
        type: "sql",
        visibleTables: ['PACIENTES', 'MEDICAMENTOS', 'CLINICAS', 'PROVINCIAS', 'DISPENSAS'],
        initialCode: `-- Escribe tu consulta aquÃ­
SELECT * FROM DISPENSAS`,
        solution: `SELECT 
    ISNULL(PR.ProvinciaDesc, '') AS Provincia,
    P.Nombre,
    P.Apellido,
    COUNT(D.DispensaID) AS CantidadDispensas
FROM DISPENSAS D
INNER JOIN PACIENTES P ON D.PacienteID = P.PacienteID
LEFT JOIN PROVINCIAS PR ON P.ProvinciaID = PR.ProvinciaID
GROUP BY PR.ProvinciaDesc, P.PacienteID, P.Nombre, P.Apellido
HAVING COUNT(D.DispensaID) > 2`,
        solutionExplanation: `
**SoluciÃ³n de CÃ¡tedra:**

\`\`\`sql
SELECT 
    ISNULL(PR.ProvinciaDesc, '') AS Provincia,
    P.Nombre,
    P.Apellido,
    COUNT(D.DispensaID) AS CantidadDispensas
FROM DISPENSAS D
INNER JOIN PACIENTES P ON D.PacienteID = P.PacienteID
LEFT JOIN PROVINCIAS PR ON P.ProvinciaID = PR.ProvinciaID
GROUP BY PR.ProvinciaDesc, P.PacienteID, P.Nombre, P.Apellido
HAVING COUNT(D.DispensaID) > 2
\`\`\`

**Elementos clave:**
- **COUNT(D.DispensaID)** para contar dispensas (mejor prÃ¡ctica acadÃ©mica - evitar COUNT(*))
- **GROUP BY** por Provincia y Paciente (acepta agrupar por PR.ProvinciaDesc o PR.ProvinciaID)
- **HAVING COUNT(...) > 2** para filtrar agregados
- **ISNULL** para manejar provincias nulas
        `,
        validate: (userQuery) => {
            try {
                // Normalize user query: Replace COUNT(column) or COUNT(1) with COUNT(*) for validation
                // This allows students to use COUNT(ID) or COUNT(1) as best practice
                const normalizedUserQuery = userQuery.replace(/COUNT\s*\(\s*[^)]+\s*\)/gi, 'COUNT(*)');

                // Also normalize GROUP BY to accept both ProvinciaDesc and ProvinciaID
                // Accept GROUP BY PR.ProvinciaID even when SELECT uses ISNULL(PR.ProvinciaDesc, '')
                const normalizedForGroupBy = normalizedUserQuery
                    .replace(/GROUP\s+BY\s+PR\.ProvinciaID/gi, 'GROUP BY PR.ProvinciaDesc')
                    .replace(/GROUP\s+BY\s+ISNULL\s*\([^)]+\)/gi, 'GROUP BY PR.ProvinciaDesc');

                const canonicalQuery = `
                    SELECT 
                        ISNULL(PR.ProvinciaDesc, '') AS Provincia,
                        P.Nombre,
                        P.Apellido,
                        COUNT(*) AS CantidadDispensas
                    FROM DISPENSAS D
                    INNER JOIN PACIENTES P ON D.PacienteID = P.PacienteID
                    LEFT JOIN PROVINCIAS PR ON P.ProvinciaID = PR.ProvinciaID
                    GROUP BY PR.ProvinciaDesc, P.PacienteID, P.Nombre, P.Apellido
                    HAVING COUNT(*) > 2
                `;
                const expected = alasql(canonicalQuery);
                const actual = alasql(normalizedForGroupBy);

                const sortFn = (a, b) => a.Nombre.localeCompare(b.Nombre);

                // Use compareQueryResults to ignore column names
                if (compareQueryResults(expected, actual, sortFn)) {
                    return { success: true, message: "Â¡Correcto! Los resultados coinciden con la soluciÃ³n esperada." };
                } else {
                    return {
                        success: false,
                        message: "Los resultados no coinciden. Verifica: COUNT(ID/1), GROUP BY, HAVING y ISNULL.",
                        expected,
                        actual
                    };
                }
            } catch (e) {
                return { success: false, message: "âŒ Error SQL: " + e.message, isSyntaxError: true };
            }
        }
    },

    // ============================================================================
    // CATEGORÃA B: DIVISIÃ“N EN SQL (UNIVERSALIDAD)
    // ============================================================================
    {
        id: 'B1',
        category: 'B',
        title: "Conceptos en Todas las Cajas",
        description: "Consultar los Conceptos que tienen movimientos en todas las Cajas.",
        type: "sql",
        visibleTables: ['CAJAS', 'MOVIMIENTOS', 'CONCEPTOS', 'LOG'],
        initialCode: "-- Escribe tu consulta aquÃ­\nSELECT * FROM CONCEPTOS",
        solution: `SELECT C.ConceptoID, C.ConceptoDesc
FROM CONCEPTOS C
WHERE NOT EXISTS (
    SELECT 1
    FROM CAJAS B
    WHERE NOT EXISTS (
        SELECT 1
        FROM MOVIMIENTOS M
        WHERE M.CajaID = B.CajaID AND M.ConceptoID = C.ConceptoID
    )
)`,
        solutionExplanation: `
**SoluciÃ³n de CÃ¡tedra (Doble NOT EXISTS):**

Esta estructura es la Ãºnica semÃ¡nticamente correcta para la cÃ¡tedra.
Se lee como: "Busco los conceptos para los cuales NO EXISTE una caja en la cual NO EXISTE un movimiento de ese concepto".

\`\`\`sql
SELECT C.ConceptoID, C.ConceptoDesc
FROM CONCEPTOS C
WHERE NOT EXISTS (
    SELECT 1
    FROM CAJAS B
    WHERE NOT EXISTS (
        SELECT 1
        FROM MOVIMIENTOS M
        WHERE M.CajaID = B.CajaID AND M.ConceptoID = C.ConceptoID
    )
)
\`\`\`

**Â¿Por quÃ© no COUNT?**
El uso de COUNT puede fallar si hay duplicados o si la integridad referencial no es estricta en otros contextos. La divisiÃ³n relacional pura se expresa con cuantificadores universales, que en SQL se traducen a Doble NOT EXISTS.
        `,
        validate: (userQuery) => {
            try {
                const canonicalQuery = `
                    SELECT C.ConceptoID, C.ConceptoDesc
                    FROM CONCEPTOS C
                    WHERE NOT EXISTS (
                        SELECT 1
                        FROM CAJAS B
                        WHERE NOT EXISTS (
                            SELECT 1
                            FROM MOVIMIENTOS M
                            WHERE M.CajaID = B.CajaID AND M.ConceptoID = C.ConceptoID
                        )
                    )
                `;
                const expected = alasql(canonicalQuery);
                const actual = alasql(userQuery);

                const sortFn = (a, b) => a.ConceptoID - b.ConceptoID;

                // Use compareQueryResults to ignore column names
                if (compareQueryResults(expected, actual, sortFn)) {
                    return { success: true, message: "Â¡Correcto! Los resultados coinciden con la soluciÃ³n esperada." };
                } else {
                    return { success: false, message: "Los resultados no coinciden. Verifica la estructura de Doble NOT EXISTS.", expected, actual };
                }
            } catch (e) {
                return { success: false, message: "âŒ Error SQL: " + e.message, isSyntaxError: true };
            }
        }
    },
    {
        id: 'B2',
        category: 'B',
        title: "ClÃ­nicas Federales",
        description: "Obtener los nombres de las clÃ­nicas que han atendido a pacientes de todas las provincias (Salta y CABA).",
        type: "sql",
        visibleTables: ['PACIENTES', 'CLINICAS', 'PROVINCIAS', 'DISPENSAS'],
        initialCode: `-- Escribe tu consulta aquÃ­
SELECT * FROM CLINICAS`,
        solution: `SELECT DISTINCT CL.ClinicaDesc
FROM CLINICAS CL
WHERE NOT EXISTS (
    SELECT * FROM PROVINCIAS PR
    WHERE PR.ProvinciaDesc IN ('Salta', 'CABA')
      AND NOT EXISTS (
        SELECT * FROM DISPENSAS D
        INNER JOIN PACIENTES P ON D.PacienteID = P.PacienteID
        WHERE D.ClinicaID = CL.ClinicaID AND P.ProvinciaID = PR.ProvinciaID
    )
)`,
        solutionExplanation: `
**SoluciÃ³n de CÃ¡tedra (Doble NOT EXISTS):**

"No existe una provincia (de las especificadas) para la cual no exista una dispensa en esa clÃ­nica de un paciente de esa provincia."

\`\`\`sql
SELECT DISTINCT CL.ClinicaDesc
FROM CLINICAS CL
WHERE NOT EXISTS (
    SELECT * FROM PROVINCIAS PR
    WHERE PR.ProvinciaDesc IN ('Salta', 'CABA')
      AND NOT EXISTS (
        SELECT * FROM DISPENSAS D
        INNER JOIN PACIENTES P ON D.PacienteID = P.PacienteID
        WHERE D.ClinicaID = CL.ClinicaID AND P.ProvinciaID = PR.ProvinciaID
    )
)
\`\`\`

**DivisiÃ³n clÃ¡sica:** ClÃ­nicas que cubrieron TODAS las provincias especificadas.
        `,
        validate: (userQuery) => {
            try {
                const canonicalQuery = `
                    SELECT DISTINCT CL.ClinicaDesc
                    FROM CLINICAS CL
                    WHERE NOT EXISTS (
                        SELECT * FROM PROVINCIAS PR
                        WHERE PR.ProvinciaDesc IN ('Salta', 'CABA')
                          AND NOT EXISTS (
                            SELECT * FROM DISPENSAS D
                            INNER JOIN PACIENTES P ON D.PacienteID = P.PacienteID
                            WHERE D.ClinicaID = CL.ClinicaID AND P.ProvinciaID = PR.ProvinciaID
                        )
                    )
                `;
                const expected = alasql(canonicalQuery);
                const actual = alasql(userQuery);

                const sortFn = (a, b) => a.ClinicaDesc.localeCompare(b.ClinicaDesc);

                // Use compareQueryResults to ignore column names
                if (compareQueryResults(expected, actual, sortFn)) {
                    return { success: true, message: "Â¡Correcto! Los resultados coinciden con la soluciÃ³n esperada." };
                } else {
                    return { success: false, message: "Los resultados no coinciden. Verifica la estructura de Doble NOT EXISTS.", expected, actual };
                }
            } catch (e) {
                return { success: false, message: "âŒ Error SQL: " + e.message, isSyntaxError: true };
            }
        }
    },
    {
        id: 'B3',
        category: 'B',
        title: "Pacientes Completos",
        description: "Obtener nombres y apellidos de pacientes que han recibido dispensas de todas las monodrogas.",
        type: "sql",
        visibleTables: ['PACIENTES', 'MEDICAMENTOS', 'DISPENSAS'],
        initialCode: `-- Escribe tu consulta aquÃ­
SELECT * FROM PACIENTES`,
        solution: `SELECT P.Nombre, P.Apellido
FROM PACIENTES P
WHERE NOT EXISTS (
    SELECT * FROM MONODROGAS MD
    WHERE NOT EXISTS (
        SELECT * FROM DISPENSAS D
        INNER JOIN MEDICAMENTOS M ON D.MedID = M.MedID
        WHERE D.PacienteID = P.PacienteID AND M.MedMonodroga = MD.MonodrogaDesc
    )
)`,
        solutionExplanation: `
**SoluciÃ³n de CÃ¡tedra (Doble NOT EXISTS):**

"No existe una monodroga para la cual no exista una dispensa de esa monodroga para ese paciente."

\`\`\`sql
SELECT P.Nombre, P.Apellido
FROM PACIENTES P
WHERE NOT EXISTS (
    SELECT * FROM MONODROGAS MD
    WHERE NOT EXISTS (
        SELECT * FROM DISPENSAS D
        INNER JOIN MEDICAMENTOS M ON D.MedID = M.MedID
        WHERE D.PacienteID = P.PacienteID AND M.MedMonodroga = MD.MonodrogaDesc
    )
)
\`\`\`

**DivisiÃ³n:** Pacientes que recibieron TODAS las monodrogas disponibles.
        `,
        validate: (userQuery) => {
            try {
                const canonicalQuery = `
                    SELECT P.Nombre, P.Apellido
                    FROM PACIENTES P
                    WHERE NOT EXISTS (
                        SELECT * FROM MONODROGAS MD
                        WHERE NOT EXISTS (
                            SELECT * FROM DISPENSAS D
                            INNER JOIN MEDICAMENTOS M ON D.MedID = M.MedID
                            WHERE D.PacienteID = P.PacienteID AND M.MedMonodroga = MD.MonodrogaDesc
                        )
                    )
                `;
                const expected = alasql(canonicalQuery);
                const actual = alasql(userQuery);

                const sortFn = (a, b) => a.Nombre.localeCompare(b.Nombre);

                // Use compareQueryResults to ignore column names
                if (compareQueryResults(expected, actual, sortFn)) {
                    return { success: true, message: "Â¡Correcto! Los resultados coinciden con la soluciÃ³n esperada." };
                } else {
                    return { success: false, message: "Los resultados no coinciden. Verifica la estructura de Doble NOT EXISTS.", expected, actual };
                }
            } catch (e) {
                return { success: false, message: "âŒ Error SQL: " + e.message, isSyntaxError: true };
            }
        }
    },

    // ============================================================================
    // CATEGORÃA C: ÃLGEBRA RELACIONAL (MULTIPLE CHOICE)
    // ============================================================================
    {
        id: 'C1',
        category: 'C',
        title: "DivisiÃ³n Simple (Ãlgebra)",
        description: "Indique el Ã¡lgebra relacional para obtener los Pacientes que recibieron todas las Monodrogas.",
        type: "multiple-choice",
        visibleTables: ['PACIENTES', 'MEDICAMENTOS', 'DISPENSAS'],
        options: [
            {
                id: "A",
                label: "X1 = Ï€ PacienteID (Dispensas) ... (OpciÃ³n incorrecta con Join simple)",
                correct: false
            },
            {
                id: "B",
                label: "X1 = Ï€ PacienteID (Dispensas) ... X2 = Ï€ PacienteID ((X1 Ã— Monodrogas) - Dispensas) ... R = X1 - X2",
                correct: true,
                explanation: "Correcto. Se usa el MÃ©todo de los 3 Pasos (Candidatos, Descalificados, Resultado) simulando la DivisiÃ³n con ProyecciÃ³n y Diferencia."
            },
            {
                id: "C",
                label: "X1 = Ïƒ PacienteID (Dispensas) / Monodrogas",
                correct: false
            }
        ],
        solutionExplanation: `
**MÃ©todo de los 3 Pasos (DivisiÃ³n):**

1. **Candidatos ($X_1$):** Todos los pacientes que tienen al menos una dispensa.
   $X_1 = \\pi_{PacienteID}(Dispensas)$

2. **Descalificados ($X_2$):** Pacientes que les falta al menos una monodroga.
   Se forma el producto cartesiano de Candidatos con TODAS las Monodrogas, y se le restan las combinaciones que REALMENTE existen (Dispensas). Lo que queda son las combinaciones "faltantes".
   $X_2 = \\pi_{PacienteID}((X_1 \\times Monodrogas) - Dispensas)$

3. **Resultado:** Candidatos menos Descalificados.
   $Resultado = X_1 - X_2$
        `
    },
    {
        id: 'C2',
        category: 'C',
        title: "DivisiÃ³n de ClÃ­nicas (Ãlgebra)",
        description: "Ãlgebra relacional para obtener las ClÃ­nicas que atendieron pacientes de todas las provincias (Salta y CABA).",
        type: "multiple-choice",
        visibleTables: ['PACIENTES', 'CLINICAS', 'PROVINCIAS', 'DISPENSAS'],
        options: [
            {
                id: "A",
                label: "X1 = Ï€ ClinicaID (Dispensas â‹ˆ Pacientes) ... X2 = Ïƒ ProvinciaDesc IN ('Salta','CABA') (Provincias) ... R = X1 â‹ˆ X2",
                correct: false
            },
            {
                id: "B",
                label: "X1 = Ï€ ClinicaID (Dispensas â‹ˆ Pacientes) ... X2 = Ï€ ClinicaID, ProvinciaID (X1 Ã— Ïƒ ProvinciaDesc IN ('Salta','CABA') (Provincias)) ... X3 = X2 - Ï€ ClinicaID, ProvinciaID (Dispensas â‹ˆ Pacientes) ... R = X1 - Ï€ ClinicaID (X3)",
                correct: true,
                explanation: "Correcto. MÃ©todo de 3 pasos: 1) Candidatos (ClÃ­nicas), 2) Producto cartesiano menos realidad (Descalificados), 3) Resta final."
            },
            {
                id: "C",
                label: "R = Ï€ ClinicaDesc (Clinicas Ã· Provincias)",
                correct: false
            }
        ],
        solutionExplanation: `
**MÃ©todo de los 3 Pasos aplicado a ClÃ­nicas:**

1. **Candidatos:** ClÃ­nicas que tienen al menos una dispensa
   $X_1 = \\pi_{ClinicaID}(Dispensas \\bowtie Pacientes)$

2. **Descalificados:** ClÃ­nicas que NO atendieron alguna provincia
   $Provincias\\_Requeridas = \\sigma_{ProvinciaDesc \\in ('Salta','CABA')}(Provincias)$
   $Todas\\_Combinaciones = X_1 \\times Provincias\\_Requeridas$
   $Combinaciones\\_Reales = \\pi_{ClinicaID, ProvinciaID}(Dispensas \\bowtie Pacientes)$
   $X_3 = Todas\\_Combinaciones - Combinaciones\\_Reales$

3. **Resultado:** Candidatos menos Descalificados
   $R = X_1 - \\pi_{ClinicaID}(X_3)$
        `
    },
    {
        id: 'C3',
        category: 'C',
        title: "Consulta Compleja (Ãlgebra)",
        description: "Ãlgebra para: Nombres de pacientes, nombre de sus titulares (si no son titulares mostrar \"\"), y clÃ­nica donde se dispensÃ³ en Septiembre 2023.",
        type: "multiple-choice",
        visibleTables: ['PACIENTES', 'CLINICAS', 'DISPENSAS'],
        options: [
            {
                id: "A",
                label: "R = Ï€ Nombre, ClinicaDesc (Pacientes â‹ˆ Dispensas â‹ˆ Clinicas)",
                correct: false
            },
            {
                id: "B",
                label: "T1 = Ï Titular â† Pacientes ... T2 = Ïƒ Fecha >= '2023-09-01' AND Fecha <= '2023-09-30' (Dispensas) ... R = Ï€ P.Nombre, ISNULL(T.Nombre,'') AS Titular, C.ClinicaDesc (Pacientes P âŸ• T1 T ON P.TitularID = T.PacienteID â‹ˆ T2 â‹ˆ Clinicas C)",
                correct: true,
                explanation: "Correcto. Incluye: Renombramiento (Ï) para self-join de titulares, SelecciÃ³n (Ïƒ) por fecha, LEFT JOIN para titular opcional, y ProyecciÃ³n final."
            },
            {
                id: "C",
                label: "R = Ï€ Nombre, ClinicaDesc (Ïƒ Fecha = 'Sep 2023' (Dispensas â‹ˆ Pacientes â‹ˆ Clinicas))",
                correct: false
            }
        ],
        solutionExplanation: `
**Consulta Compleja - Elementos Clave:**

1. **Renombramiento ($\\rho$):** Para hacer self-join de Pacientes con Titulares
   $Titular = \\rho_{Titular \\leftarrow Pacientes}(Pacientes)$

2. **SelecciÃ³n ($\\sigma$):** Filtrar por rango de fechas
   $Dispensas\\_Sep = \\sigma_{Fecha >= '2023-09-01' \\land Fecha <= '2023-09-30'}(Dispensas)$

3. **Joins:** LEFT JOIN para titular (puede ser NULL), INNER JOIN para Dispensas y ClÃ­nicas

4. **ProyecciÃ³n ($\\pi$):** Seleccionar columnas finales con ISNULL para manejar NULLs

**Estructura completa:**
$\\pi_{P.Nombre, ISNULL(T.Nombre,''), C.ClinicaDesc}(Pacientes\\ P \\;âŸ•\\; Titular\\ T \\;â‹ˆ\\; Dispensas\\_Sep \\;â‹ˆ\\; Clinicas\\ C)$
        `
    },

    // ============================================================================
    // CATEGORÃA D: TRIGGERS (AUDITORÃA AVANZADA)
    // ============================================================================
    {
        id: 'D1',
        category: 'D',
        title: "Update Simple (Trigger)",
        description: "Escriba el cuerpo de un Trigger para auditar UPDATE en Pacientes. Debe guardar el PacienteID y la operaciÃ³n 'UPD PACIENTE' en la tabla LOG.",
        type: "code-validation",
        visibleTables: ['PACIENTES', 'LOG'],
        initialCode: `CREATE TRIGGER trg_AuditoriaPacientes ON PACIENTES
AFTER UPDATE
AS
BEGIN
    -- Tu cÃ³digo aquÃ­
END`,
        solution: `CREATE TRIGGER trg_AuditoriaPacientes ON PACIENTES
AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;
    
    INSERT INTO LOG (ObjetoId, Operacion, FechaHora)
    SELECT PacienteID, 'UPD PACIENTE', GETDATE()
    FROM inserted;
END`,
        // Automatic trigger test execution
        postExecutionSQL: "UPDATE PACIENTES SET Nombre = 'Juan Modificado' WHERE PacienteID = 1",
        resultQuery: "SELECT * FROM LOG ORDER BY FechaHora DESC",
        solutionExplanation: `
**ValidaciÃ³n Estricta:**

1. **SET NOCOUNT ON:** Obligatorio para evitar interferir con el trÃ¡fico de red y aplicaciones cliente.
2. **FROM inserted:** Obligatorio. NUNCA usar variables escalares (ej: @id = PacienteID) porque el trigger se dispara una vez por lote (batch), no por fila. Si se actualizan 10 filas, el trigger corre 1 vez y \`inserted\` tiene 10 filas.
3. **Operaciones de Conjunto:** Se debe usar INSERT ... SELECT ... FROM inserted.
        `,
        validate: (code) => {
            const checks = [
                { regex: /SET\s+NOCOUNT\s+ON/i, msg: "Falta 'SET NOCOUNT ON'" },
                { regex: /FROM\s+inserted/i, msg: "Debe utilizar la tabla virtual 'inserted'" },
                { regex: /INSERT\s+INTO\s+LOG/i, msg: "Debe insertar en la tabla LOG" }
            ];

            if (/SELECT\s+@\w+\s*=\s*\w+/i.test(code)) {
                return { success: false, message: "Error: Uso de variables escalares detectado. El trigger debe manejar mÃºltiples filas (lotes)." };
            }

            for (let check of checks) {
                if (!check.regex.test(code)) {
                    return { success: false, message: `Error: ${check.msg}` };
                }
            }

            return { success: true, message: "Â¡CÃ³digo vÃ¡lido segÃºn estÃ¡ndares de cÃ¡tedra!" };
        }
    },
    {
        id: 'D2',
        category: 'D',
        title: "Update con Valores Viejos/Nuevos",
        description: "Trigger al actualizar un CONCEPTO: Agregue al LOG un registro con: ConceptoID, \"Texto Anterior\" (ConceptoDesc viejo), \"Texto Nuevo\" (ConceptoDesc nuevo) y Fecha.",
        type: "code-validation",
        visibleTables: ['CONCEPTOS', 'LOG_CONCEPTOS'],
        initialCode: `CREATE TRIGGER trg_AuditoriaConceptos ON CONCEPTOS
AFTER UPDATE
AS
BEGIN
    -- Tu cÃ³digo aquÃ­
END`,
        solution: `CREATE TRIGGER trg_AuditoriaConceptos ON CONCEPTOS
AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;
    
    INSERT INTO LOG_CONCEPTOS (ConceptoID, TextoAnterior, TextoNuevo, Fecha)
    SELECT 
        i.ConceptoID, 
        d.ConceptoDesc AS TextoAnterior,
        i.ConceptoDesc AS TextoNuevo,
        GETDATE()
    FROM inserted i
    INNER JOIN deleted d ON i.ConceptoID = d.ConceptoID;
END`,
        // Automatic trigger test execution
        postExecutionSQL: "UPDATE CONCEPTOS SET ConceptoDesc = 'Concepto Actualizado' WHERE ConceptoID = 1",
        resultQuery: "SELECT * FROM LOG_CONCEPTOS ORDER BY Fecha DESC",
        solutionExplanation: `
**ValidaciÃ³n Estricta para UPDATE:**

1. **SET NOCOUNT ON:** Obligatorio
2. **JOIN entre inserted y deleted:** Se debe hacer JOIN para correlacionar valores viejos y nuevos
3. **d.ConceptoDesc (viejo)** de la tabla **deleted**
4. **i.ConceptoDesc (nuevo)** de la tabla **inserted**
5. **INSERT ... SELECT ... FROM inserted JOIN deleted**

\`\`\`sql
INSERT INTO LOG_CONCEPTOS (ConceptoID, TextoAnterior, TextoNuevo, Fecha)
SELECT 
    i.ConceptoID, 
    d.ConceptoDesc AS TextoAnterior,
    i.ConceptoDesc AS TextoNuevo,
    GETDATE()
FROM inserted i
INNER JOIN deleted d ON i.ConceptoID = d.ConceptoID
\`\`\`
        `,
        validate: (code) => {
            const checks = [
                { regex: /SET\s+NOCOUNT\s+ON/i, msg: "Falta 'SET NOCOUNT ON'" },
                { regex: /FROM\s+inserted/i, msg: "Debe utilizar la tabla virtual 'inserted'" },
                { regex: /deleted/i, msg: "Debe utilizar la tabla virtual 'deleted' para obtener valores anteriores" },
                { regex: /JOIN/i, msg: "Debe hacer JOIN entre 'inserted' y 'deleted'" }
            ];

            if (/SELECT\s+@\w+\s*=\s*\w+/i.test(code)) {
                return { success: false, message: "Error: Uso de variables escalares detectado. El trigger debe manejar mÃºltiples filas (lotes)." };
            }

            for (let check of checks) {
                if (!check.regex.test(code)) {
                    return { success: false, message: `Error: ${check.msg}` };
                }
            }

            return { success: true, message: "Â¡CÃ³digo vÃ¡lido segÃºn estÃ¡ndares de cÃ¡tedra!" };
        }
    },

    // ============================================================================
    // CATEGORÃA E: TEORÃA DE TRANSACCIONES
    // ============================================================================
    {
        id: 'E1',
        category: 'E',
        title: "Lectura Fantasma",
        description: "Si debo obtener el MAX(ID) + 1 para insertar un nuevo registro y asegurar que nadie mÃ¡s use ese ID concurrentemente, Â¿quÃ© nivel de aislamiento debo usar para evitar lecturas fantasma?",
        type: "multiple-choice",
        visibleTables: ['MEDICAMENTOS'],
        options: [
            { id: "A", label: "READ COMMITTED", correct: false },
            { id: "B", label: "REPEATABLE READ", correct: false },
            { id: "C", label: "SERIALIZABLE", correct: true, explanation: "Correcto. SERIALIZABLE es el Ãºnico nivel que previene lecturas fantasma mediante bloqueos de rango (Range Locks), asegurando que nadie inserte un nuevo ID mientras calculamos el MAX." },
            { id: "D", label: "SNAPSHOT", correct: false }
        ],
        solutionExplanation: `
**Respuesta: SERIALIZABLE**

Para calcular \`MAX(ID) + 1\` de forma segura sin usar secuencias/identity (escenario tÃ­pico de parcial), necesitamos evitar que otra transacciÃ³n inserte un valor que cambie ese mÃ¡ximo mientras leemos.

- **READ COMMITTED** y **REPEATABLE READ** no evitan lecturas fantasma (nuevas filas insertadas por otros).
- **SERIALIZABLE** coloca bloqueos de rango (Range Locks) que impiden inserciones en el rango afectado, garantizando exclusividad total.
        `
    },
    {
        id: 'E2',
        category: 'E',
        title: "Integridad Maestro-Detalle",
        description: "Al insertar un REMITO se deben insertar sus DETALLES. Para asegurar que se graben todos o ninguno, Â¿quÃ© mecanismo es fundamental?",
        type: "multiple-choice",
        visibleTables: ['MEDICAMENTOS'],
        options: [
            {
                id: "A",
                label: "Solo Bloqueos (Locks)",
                correct: false
            },
            {
                id: "B",
                label: "TransacciÃ³n ExplÃ­cita (BEGIN TRANSACTION / COMMIT / ROLLBACK)",
                correct: true,
                explanation: "Correcto. La atomicidad (todo o nada) se garantiza con transacciones explÃ­citas. Si falla algÃºn INSERT, se hace ROLLBACK de todos."
            },
            {
                id: "C",
                label: "Nivel de Aislamiento SERIALIZABLE",
                correct: false
            },
            {
                id: "D",
                label: "Constraints de Foreign Key",
                correct: false
            }
        ],
        solutionExplanation: `
**Respuesta: TransacciÃ³n ExplÃ­cita (BEGIN/COMMIT/ROLLBACK)**

**Atomicidad:** Propiedad ACID que garantiza que todas las operaciones de una transacciÃ³n se completen o ninguna.

**Ejemplo:**
\`\`\`sql
BEGIN TRANSACTION
    INSERT INTO REMITOS (RemitoID, ...) VALUES (...)
    INSERT INTO DETALLES_REMITO (RemitoID, ...) VALUES (...)
    INSERT INTO DETALLES_REMITO (RemitoID, ...) VALUES (...)
    
    IF @@ERROR <> 0
        ROLLBACK
    ELSE
        COMMIT
\`\`\`

- **BEGIN TRANSACTION:** Inicia la transacciÃ³n
- **COMMIT:** Confirma todos los cambios si todo fue exitoso
- **ROLLBACK:** Deshace todos los cambios si hubo algÃºn error

Los **Locks** controlan concurrencia, no atomicidad. 
El nivel **SERIALIZABLE** controla aislamiento, no atomicidad.
        `
    },
